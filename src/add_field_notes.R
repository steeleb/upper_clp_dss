#' @title Integrate field notes with water quality monitoring data
#'
#' @description
#' This function merges sensor readings with important field
#' observations about equipment status, maintenance activities, calibration events,
#' and site conditions.
#'
#' The function handles the complexity of matching timestamped field notes to the
#' continuous time series data, ensuring that important information about sensor
#' deployment, maintenance, and observed issues is properly associated with all
#' relevant data points. It also performs forward-filling of certain field attributes
#' to maintain continuity of status information (like deployment status) between
#' field visits.
#'
#' @param df A dataframe containing processed time series data for a single
#' site-parameter combination, typically an element generated by `combine_datasets`.
#'
#' @param notes A dataframe containing processed field notes from mWater, typically
#' the output from `grab_mWater_sensor_notes()`. These notes include information
#' about sensor deployment, maintenance, and observed issues.
#'
#' @return A dataframe containing the original time series data enriched with
#' field note information:
#' - All columns from the original time series data
#' - sonde_employed: Indicator of sensor deployment status
#' - sonde_moved: Indicator of sensor position changes
#' - last_site_visit: Timestamp of most recent site visit
#' - visit_comments: Technician observations during site visits
#' - sensor_malfunction: Noted sensor issues
#' - cals_performed: Calibration events
#'
#' Field status information is forward-filled to maintain continuity between
#' site visits.
#'
#' @examples
#' # Load field notes
#' mWater_data <- load_mWater(creds = yaml::read_yaml("creds/mWaterCreds.yml"))
#' field_notes <- grab_mWater_sensor_notes(mWater_api_data = mWater_data)
#'
#' # Add field notes to temperature data for riverbluffs site
#' riverbluffs_temp_with_notes <- add_field_notes(
#'   df = tidy_api_data(new_data[["riverbluffs-Temperature"]]),
#'   notes = field_notes
#' )
#'
#' @seealso [grab_mWater_sensor_notes()]
#' @seealso [tidy_api_data()]
#' @seealso [combine_datasets()]
#' @seealso [generate_summary_statistics()]
#' @seealso [add_field_flag()]

add_field_notes <- function(df, notes) {

  # Extract site and parameter information from the input data
  site_arg <- unique(df$site)
  parameter_arg <- unique(df$parameter)

  # Filter field notes to include only those relevant to this site
  # This uses a flexible matching approach that handles variations in site naming
  site_field_notes <- notes %>%
    dplyr::filter(grepl(paste(unlist(stringr::str_split(site_arg, "[\\s_]+")),
                             collapse = "|"), site, ignore.case = TRUE))

  # Process the data within a tryCatch to handle potential errors gracefully
  summary <- tryCatch({
    df %>%
      # Remove any duplicate records that might have been introduced
      dplyr::distinct() %>%

      # Join the time series data with relevant field note information
      # This adds human observations to the sensor readings
      dplyr::full_join(., dplyr::select(site_field_notes,
                                      sonde_employed, sonde_moved,
                                      last_site_visit, DT_join, visit_comments,
                                      sensor_malfunction, cals_performed),
                       by = c('DT_join')) %>%

      # Ensure proper temporal ordering of the combined data
      arrange((DT_join)) %>%

      # Ensure timestamps remain in correct datetime format after joining
      dplyr::mutate(DT_round = lubridate::as_datetime(DT_join, tz = "UTC")) %>%

      # Set default sonde_employed status (0 = deployed/in water)
      # and forward-fill deployment status and site visit information
      # This maintains status continuity between discrete field observations
      dplyr::mutate(sonde_employed = ifelse(is.na(sonde_employed), 0, sonde_employed)) %>%
      tidyr::fill(c(sonde_employed, last_site_visit, sensor_malfunction)) %>%

      # Handle special case: If no site visit information exists at the beginning
      # of the record, assume sonde was not yet deployed (sonde_employed = 1)
      dplyr::mutate(sonde_employed = ifelse(is.na(last_site_visit), 1, sonde_employed)) %>%

      # Final cleanup of any duplicates and rows with missing site information
      dplyr::distinct(.keep_all = TRUE) %>%
      dplyr::filter(!is.na(site))
  },
  error = function(err) {
    # Provide informative error message if processing fails
    cat("An error occurred with site ", site_arg, " parameter ", parameter_arg, ".\n")
    cat("Error message:", conditionMessage(err), "\n")
    flush.console() # Immediately print the error messages
    NULL # Return NULL in case of an error
  })

  return(summary)
}
